import { NextRequest } from 'next/server';

// Mock the dependencies
jest.mock('@/lib/amplify', () => ({
  ensureAmplifyConfigured: jest.fn().mockResolvedValue(undefined)
}));

// Mock the client variable to ensure fresh instances
let mockClientInstance: any = null;

jest.mock('aws-amplify/data', () => ({
  generateClient: jest.fn(() => mockClientInstance)
}));

jest.mock('@/lib/api-utils', () => ({
  createErrorResponse: jest.fn((error, code, status, details) => {
    return new Response(JSON.stringify({ success: false, error, code, details, timestamp: new Date().toISOString() }), {
      status: status || 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }),
  createSuccessResponse: jest.fn((data, status = 200) => {
    return new Response(JSON.stringify({ success: true, ...data, timestamp: new Date().toISOString() }), {
      status: status,
      headers: { 'Content-Type': 'application/json' }
    });
  }),
  validateRequestBody: jest.fn(),
  applyRateLimit: jest.fn()
}));

describe('/api/cancel-registration', () => {
  let mockClient: any;
  let mockValidateRequestBody: jest.MockedFunction<any>;
  let mockApplyRateLimit: jest.MockedFunction<any>;
  let POST: any;
  let GET: any;

  beforeEach(() => {
    // Clear module cache to ensure fresh imports
    delete require.cache[require.resolve('../cancel-registration/route')];
    delete require.cache[require.resolve('@/lib/amplify')];
    delete require.cache[require.resolve('aws-amplify/data')];
    
    // Setup mock client
    mockClient = {
      models: {
        Registration: {
          list: jest.fn(),
          update: jest.fn()
        }
      }
    };
    
    // Set the global mock instance
    mockClientInstance = mockClient;

    // Setup api-utils mocks
    const apiUtils = require('@/lib/api-utils');
    mockValidateRequestBody = apiUtils.validateRequestBody;
    mockApplyRateLimit = apiUtils.applyRateLimit;
    
    // Reset mocks
    jest.clearAllMocks();
    
    // Reset client mock default return values
    mockClient.models.Registration.list.mockResolvedValue({ data: [] });
    mockClient.models.Registration.update.mockResolvedValue({ errors: null });
    
    // Import the route handlers fresh each time to reset client cache
    const route = require('../cancel-registration/route');
    POST = route.POST;
    GET = route.GET;
  });

  describe('POST /api/cancel-registration', () => {
    const validToken = 'test-token-123';
    const validRegistration = {
      id: 'reg-123',
      firstName: 'John',
      lastName: 'Doe',
      timeSlot: '10:00',
      numberOfKids: 2,
      registrationStatus: 'unconfirmed'
    };

    beforeEach(() => {
      // Default successful validation and no rate limiting  
      mockValidateRequestBody.mockResolvedValue({
        success: true,
        data: { token: validToken }
      });
      mockApplyRateLimit.mockReturnValue(null);
      
      // Default to finding no registrations (tests will override as needed)
      mockClient.models.Registration.list.mockResolvedValue({ data: [] });
    });

    it('should successfully cancel an unconfirmed registration', async () => {
      // Mock finding the registration
      mockClient.models.Registration.list.mockResolvedValue({
        data: [validRegistration]
      });

      // Mock successful update
      mockClient.models.Registration.update.mockResolvedValue({
        errors: null
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(mockClient.models.Registration.list).toHaveBeenCalledWith({
        filter: { finalConfirmationToken: { eq: validToken } }
      });

      expect(mockClient.models.Registration.update).toHaveBeenCalledWith({
        id: validRegistration.id,
        registrationStatus: 'cancelled',
        isCancelled: true,
        cancelledAt: expect.any(String)
      });

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.registration.status).toBe('cancelled');
    });

    it('should successfully cancel a confirmed registration', async () => {
      const confirmedRegistration = {
        ...validRegistration,
        registrationStatus: 'confirmed'
      };

      mockClient.models.Registration.list.mockResolvedValue({
        data: [confirmedRegistration]
      });

      mockClient.models.Registration.update.mockResolvedValue({
        errors: null
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
    });

    it('should handle already cancelled registration', async () => {
      const cancelledRegistration = {
        ...validRegistration,
        registrationStatus: 'cancelled'
      };

      mockClient.models.Registration.list.mockResolvedValue({
        data: [cancelledRegistration]
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(200);
      expect(responseData.success).toBe(true);
      expect(responseData.registration.status).toBe('cancelled');
      expect(mockClient.models.Registration.update).not.toHaveBeenCalled();
    });

    it('should reject invalid token', async () => {
      mockClient.models.Registration.list.mockResolvedValue({
        data: []
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: 'invalid-token' })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(404);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('INVALID_TOKEN');
    });

    it('should handle registration with invalid status', async () => {
      const registeredRegistration = {
        ...validRegistration,
        registrationStatus: 'registered'
      };

      mockClient.models.Registration.list.mockResolvedValue({
        data: [registeredRegistration]
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(400);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('INVALID_STATUS');
    });

    it('should handle database update errors', async () => {
      mockClient.models.Registration.list.mockResolvedValue({
        data: [validRegistration]
      });

      mockClient.models.Registration.update.mockResolvedValue({
        errors: ['Database error']
      });

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(500);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('UPDATE_FAILED');
    });

    it('should apply rate limiting', async () => {
      const rateLimitResponse = new Response(JSON.stringify({ error: 'Rate limited' }), {
        status: 429,
        headers: { 'Content-Type': 'application/json' }
      });
      mockApplyRateLimit.mockReturnValue(rateLimitResponse);

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);

      expect(response).toBe(rateLimitResponse);
      expect(mockClient.models.Registration.list).not.toHaveBeenCalled();
    });

    it('should handle validation errors', async () => {
      const validationErrorResponse = new Response(JSON.stringify({ error: 'Validation failed' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
      const validationError = {
        success: false,
        response: validationErrorResponse
      };
      mockValidateRequestBody.mockResolvedValue(validationError);

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ invalid: 'data' })
      });

      const response = await POST(request);

      expect(response).toBe(validationErrorResponse);
    });

    it('should handle unexpected errors', async () => {
      mockClient.models.Registration.list.mockRejectedValue(new Error('Database connection failed'));

      const request = new NextRequest('http://localhost:3001/api/cancel-registration', {
        method: 'POST',
        body: JSON.stringify({ token: validToken })
      });

      const response = await POST(request);
      const responseData = await response.json();

      expect(response.status).toBe(500);
      expect(responseData.success).toBe(false);
      expect(responseData.code).toBe('INTERNAL_ERROR');
    });
  });

  describe('GET /api/cancel-registration', () => {
    it('should redirect to cancellation page with valid token', async () => {
      const request = new NextRequest('http://localhost:3001/api/cancel-registration?token=test-token-123');

      const response = await GET(request);

      expect(response.status).toBe(307); // Redirect status
      expect(response.headers.get('Location')).toBe('http://localhost:3001/cancel-registration/test-token-123');
    });

    it('should redirect to error page when token is missing', async () => {
      const request = new NextRequest('http://localhost:3001/api/cancel-registration');

      const response = await GET(request);

      expect(response.status).toBe(307); // Redirect status
      expect(response.headers.get('Location')).toBe('http://localhost:3001/?error=missing-token');
    });
  });
});